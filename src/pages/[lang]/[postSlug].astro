---
// import BlogPostVue from '@layouts/BlogPost.vue'
import BlogPost from "@layouts/BlogPost.astro";
import PostBlocks from "@components/ContentBlocks.vue";
// import { Prism } from "@astrojs/prism";
import { getAllPostsWithSlugs, getPostBySlug } from "@services/api";
// import "prismjs/themes/prism-tomorrow.css";
import type {
  CoreHeadingBlock,
  RootQueryToPostConnection,
} from "@ts_types/generated/graphql";
import ListBlock from "@components/content-blocks/ListBlock.vue";
import CodeBlock from "@components/content-blocks/CodeBlock.vue";
import ButtonBlock from "@components/content-blocks/ButtonBlock.vue";
import FigureBlock from "@components/content-blocks/FigureBlock.vue";
import HeadlineBlock from "@components/content-blocks/HeadlineBlock.vue";
import ParagraphBlock from "@components/content-blocks/ParagraphBlock.vue";
import { Prism } from "@astrojs/prism";
import { parse } from "@utils/helpers";

import type { InferGetStaticParamsType, InferGetStaticPropsType } from "astro";

export const getStaticPaths = async () => {
  const postWithSlugsDe = await getAllPostsWithSlugs();
  const postWithSlugsEn = await getAllPostsWithSlugs("EN");

  const postWithSlugsAllLang = [
    ...postWithSlugsDe.edges,
    ...postWithSlugsEn.edges,
  ];

  return postWithSlugsAllLang.map(({ node }) => {
    return {
      params: {
        postSlug: node.slug,
        lang: node?.language?.slug,
      },
    };
  });
};

type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { postSlug, lang } = Astro.params as Params;
const post = await getPostBySlug(postSlug!);

const decode = (str: string) => {
  return str.replace(/&#(\d+);/g, function (match, dec) {
    return String.fromCharCode(dec);
  });
};

const exstractCode = (content: string) => {
  content = decode(content);
  const regex = /<pre .*><code>([\s\S]*?)<\/code><\/pre>/g;
  const matches = content.matchAll(regex);
  let codeBlocks = "";
  for (const match of matches) {
    codeBlocks += match[1];
  }
  return codeBlocks;
};

const findLanguage = (content: string, prefix = "lang-"): string | null => {
  const regex = new RegExp(prefix + "[a-z]+", "gm");
  const match = content.match(regex)?.toString().replace(prefix, "") as
    | string
    | null;
  return match;
};

const headings = post?.blocks?.filter(
  (block: CoreHeadingBlock) =>
    block.name === "core/heading" &&
    (JSON.parse(block.attributesJSON as string).level === 2 ||
      JSON.parse(block.attributesJSON as string).level === 3),
) as CoreHeadingBlock[];
// console.log(post.blocks[0].attributesJSON);
---

<BlogPost content={post} headings={headings}>
  {
    post?.blocks?.map((block) => {
      if (block.name === "core/list") {
        return <ListBlock block={block} />;
      }
      if (block.name === "core/code") {
        return (
          <Prism
            lang={parse(block.attributesJSON).className}
            code={parse(block.attributesJSON).content}
          />
        );
      } else {
        return <Fragment set:html={block.originalContent} />;
      }
    })
  }
</BlogPost>
